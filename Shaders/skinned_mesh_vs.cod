//
// Generated by Microsoft (R) HLSL Shader Compiler 10.1
//
//
// Buffer Definitions: 
//
// cbuffer CONSTANT_BUFFER
// {
//
//   row_major float4x4 world_view_projection;// Offset:    0 Size:    64
//   row_major float4x4 world_inverse_transpose;// Offset:   64 Size:    64 [unused]
//   float4 material_color;             // Offset:  128 Size:    16 [unused]
//   float4 light_direction;            // Offset:  144 Size:    16 [unused]
//   row_major float4x4 bone_transforms[32];// Offset:  160 Size:  2048
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- -------------- ------
// CONSTANT_BUFFER                   cbuffer      NA          NA            cb0      1 
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyzw        0     NONE   float   xyzw
// NORMAL                   0   xyzw        1     NONE   float       
// TEXCOORD                 0   xy          2     NONE   float   xy  
// WEIGHTS                  0   xyzw        3     NONE   float   xyzw
// BONES                    0   xyzw        4     NONE    uint   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy  
//
vs_5_0
dcl_globalFlags refactoringAllowed
dcl_immediateConstantBuffer { { 1.000000, 0, 0, 0},
                              { 0, 1.000000, 0, 0},
                              { 0, 0, 1.000000, 0},
                              { 0, 0, 0, 1.000000} }
dcl_constantbuffer CB0[138], dynamicIndexed
dcl_input v0.xyzw
dcl_input v2.xy
dcl_input v3.xyzw
dcl_input v4.xyzw
dcl_output_siv o0.xyzw, position
dcl_output o1.xyzw
dcl_output o2.xy
dcl_temps 4
ishl r0.xyzw, v4.xyzw, l(2, 2, 2, 2)
mul r1.xyz, v0.yyyy, cb0[r0.x + 11].xyzx
mad r1.xyz, v0.xxxx, cb0[r0.x + 10].xyzx, r1.xyzx
mad r1.xyz, v0.zzzz, cb0[r0.x + 12].xyzx, r1.xyzx
mad r1.xyz, v0.wwww, cb0[r0.x + 13].xyzx, r1.xyzx
mul r2.xyz, v0.yyyy, cb0[r0.y + 11].xyzx
mad r2.xyz, v0.xxxx, cb0[r0.y + 10].xyzx, r2.xyzx
mad r2.xyz, v0.zzzz, cb0[r0.y + 12].xyzx, r2.xyzx
mad r2.xyz, v0.wwww, cb0[r0.y + 13].xyzx, r2.xyzx
mul r2.xyz, r2.xyzx, v3.yyyy
mad r1.xyz, v3.xxxx, r1.xyzx, r2.xyzx
mul r2.xyz, v0.yyyy, cb0[r0.z + 11].xyzx
mad r2.xyz, v0.xxxx, cb0[r0.z + 10].xyzx, r2.xyzx
mad r2.xyz, v0.zzzz, cb0[r0.z + 12].xyzx, r2.xyzx
mad r0.xyz, v0.wwww, cb0[r0.z + 13].xyzx, r2.xyzx
mad r0.xyz, v3.zzzz, r0.xyzx, r1.xyzx
mul r1.xyz, v0.yyyy, cb0[r0.w + 11].xyzx
mad r1.xyz, v0.xxxx, cb0[r0.w + 10].xyzx, r1.xyzx
mad r1.xyz, v0.zzzz, cb0[r0.w + 12].xyzx, r1.xyzx
mad r1.xyz, v0.wwww, cb0[r0.w + 13].xyzx, r1.xyzx
mad r0.xyz, v3.wwww, r1.xyzx, r0.xyzx
mul r1.xyzw, r0.yyyy, cb0[1].xyzw
mad r1.xyzw, r0.xxxx, cb0[0].xyzw, r1.xyzw
mad r0.xyzw, r0.zzzz, cb0[2].xyzw, r1.xyzw
add o0.xyzw, r0.xyzw, cb0[3].xyzw
mov r0.xyzw, l(0,0,0,0)
loop 
  ige r1.x, r0.w, l(4)
  breakc_nz r1.x
  dp4 r1.y, v3.xyzw, icb[r0.w + 0].xyzw
  lt r1.w, l(0.000000), r1.y
  if_nz r1.w
    ineg r1.w, r0.w
    ult r2.xyz, r0.wwww, l(1, 2, 3, 0)
    and r3.y, r1.w, r2.y
    iadd r1.w, r0.w, l(-3)
    movc r3.z, r2.y, l(0), r1.w
    ieq r3.w, r2.z, l(0)
    mov r3.x, r2.x
    and r2.xyzw, r3.xyzw, v4.xyzw
    or r2.xy, r2.ywyy, r2.xzxx
    or r1.w, r2.y, r2.x
    switch r1.w
      case l(0)
      mov r0.x, r1.y
      break 
      case l(1)
      mov r1.xz, r0.xxzx
      mov r0.xyz, r1.xyzx
      break 
      case l(2)
      mov r0.z, r1.y
      break 
      default 
      break 
    endswitch 
  endif 
  iadd r0.w, r0.w, l(1)
endloop 
mov o1.xyz, r0.xyzx
mov o1.w, l(1.000000)
mov o2.xy, v2.xyxx
ret 
// Approximately 63 instruction slots used
